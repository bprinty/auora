"use strict";class t{constructor(){this.events={}}subscribe(t,e){const s=this;return t in s.events||(s.events[t]=[]),s.events[t].push(e)}publish(t,...e){return t in this.events?this.events[t].map(t=>t(...e)):[]}}function e(t){return void 0!==t&&"function"==typeof t.then}function s(t){return"function"==typeof t}function n(t){return Array.isArray(t)}function i(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}function r(t){return void 0===t}function c(t){if(n(t))return t.map(t=>c(t));if(i(t)){const e={};return Object.keys(t).forEach(s=>{e[s]=c(t[s])}),e}return t}const o={IDLE:"idle",RESET:"reset",ROLLBACK:"rollback",UPDATE:"update",COMMIT:"commit",MUTATE:"mutate",DISPATCH:"dispatch"};class a{constructor(t,e){this.idle=t,this.stack=[t],this.callback=e||function(){}}get current(){return this.stack[this.stack.length-1]}reset(){this.stack=[this.idle],this.callback()}push(t){this.stack.push(t)}pop(){this.stack.length>1&&(this.stack.pop(),1===this.stack.length&&this.callback())}}const u=["push","pop","shift","unshift","splice"];class b{constructor(e){this.events=new t,s(e)&&(this.events.subscribe("update",e),this.events.subscribe("delete",e),this.events.subscribe("reset",e))}subscribe(t,e){s(t)?(this.events.subscribe("update",e),this.events.subscribe("delete",e),this.events.subscribe("reset",e)):s(e)&&this.events.subscribe(t,e)}publish(t,...e){this.events.publish(t,...e)}}class h extends b{constructor(t,e,c=!0){super(e);const o=this,a=Object.assign({},t);return c&&Object.keys(t).forEach(s=>{i(t[s])?t[s]=new h(t[s],e):n(t[s])&&(t[s]=new p(t[s],e))}),new Proxy(t,{get:(u,b)=>"reset"===b?()=>{Object.keys(u).forEach(t=>{t in a?u[t]=a[t]:delete u[t]}),o.publish("reset")}:"update"===b?s=>{c&&Object.keys(s).forEach(r=>{i(s[r])?s[r]=new h(s[r],e):n(t[r])&&(s[r]=new p(s[r],e))}),u=Object.assign(u,s),o.publish("update")}:"subscribe"===b?(t,e)=>{s(t)&&r(e)?o.subscribe("update",t):o.subscribe(t,e)}:u[b],set:(t,s,r)=>(i(r)&&c?t[s]=new h(r,e):n(r)&&c?t[s]=new p(r,e):t[s]=r,o.publish(s),o.publish("update",s,r),!0),deleteProperty:(t,e)=>(delete t[e],o.publish(e),o.publish("delete",e),!0)})}}class p extends b{constructor(t,e,c=!0){super(e);const o=this,a=t.map(t=>i(t)?Object.assign({},t):n(t)?t.slice():t);return c&&(t=t.map(t=>i(t)?new h(t,e):n(t)?new p(t,e):t)),new Proxy(t,{get(t,e){if("reset"===e)return()=>{t.splice(0,t.length),t.push(...a),o.publish("reset")};if("subscribe"===e)return(t,e)=>{s(t)&&r(e)?o.subscribe("update",t):o.subscribe(t,e)};const n=t[e];return"function"==typeof n?u.includes(e)?(...s)=>{const n=t[e](...s);return o.publish(e),o.publish("update"),n}:n.bind(t):n},set:(t,s,r)=>(i(r)&&c?t[s]=new h(r,e):n(r)&&c?t[s]=new p(r,e):t[s]=r,o.publish(s),o.publish("update",s,r),!0),deleteProperty:(t,e)=>(t.splice(e,1),o.publish(e),o.publish("delete",e),!0)})}}function l(t){if(s(t))return l(t());if(n(t)){const e={};return t.forEach(t=>{e[t]=t}),e}return t}function f(t,e){const s={};!0!==t&&"*"!==t||(t=Object.keys(e.state));const n=l(t);return Object.keys(n).forEach(t=>{s[t]={cache:!1,get:()=>e.state[n[t]],set:s=>e.commit(n[t],s)}}),s}function g(t,e){const s={};!0!==t&&"*"!==t||(t=Object.keys(e.get));const n=l(t);return Object.keys(n).forEach(t=>{s[t]={cache:!1,get:()=>e.get[n[t]]}}),s}function y(t,e){const s={};if(!0===t||"*"===t){const s=Object.keys(e.state);t=Object.keys(e.mutations).filter(t=>!s.includes(t))}const n=l(t);return Object.keys(n).forEach(t=>{s[t]=(...s)=>e.commit(n[t],...s)}),s}function m(t,e){const s={};!0!==t&&"*"!==t||(t=Object.keys(e.actions));const n=l(t);return Object.keys(n).forEach(t=>{s[t]=e.apply[n[t]]}),s}const O={beforeCreate(){const t=this,e=t.$options;let n={},i={};e.store?t.$store=s(e.store)?e.store():e.store:e.parent&&e.parent.$store&&(t.$store=e.parent.$store),"state"in e&&("state"in t.$store?n=Object.assign(n,f(e.state,t.$store)):Object.keys(t.$store).forEach(s=>{s in e.state&&(n=Object.assign(n,f(e.state[s],t.$store[s])))})),"getters"in e&&("get"in t.$store?n=Object.assign(n,g(e.getters,t.$store)):Object.keys(t.$store).forEach(s=>{s in e.getters&&(n=Object.assign(n,g(e.getters[s],t.$store[s])))})),"mutations"in e&&("mutations"in t.$store?i=Object.assign(i,y(e.mutations,t.$store)):Object.keys(t.$store).forEach(s=>{s in e.mutations&&(i=Object.assign(i,y(e.mutations[s],t.$store[s])))})),"actions"in e&&("actions"in t.$store?i=Object.assign(i,m(e.actions,t.$store)):Object.keys(t.$store).forEach(s=>{s in e.actions&&(i=Object.assign(i,m(e.actions[s],t.$store[s])))})),e.computed=Object.assign(e.computed||{},n),e.methods=Object.assign(e.methods||{},i)}};var d={Store:class{constructor(e={}){const u=this;e.state=e.state||{},u.options=e.options||{type:"transactional"},u.mutations={},Object.keys(e.state).forEach(t=>{u.mutations[t]=(e,s)=>{e[t]=s}}),u.mutations=Object.assign(u.mutations,e.mutations),u.actions=e.actions||{},u.apply=new Proxy(u.actions,{get(t,e){if(e in t)return(...t)=>u.dispatch(e,...t)}}),u.cache={},e.getters=e.getters||{},u.get=new Proxy(e.getters,{get(t,e){if(!(e in t))throw new Error(`No getter defined with name \`${e}\``);if(e in u.cache)return u.cache[e];{let n=t[e](u.state);return s(n)||(u.cache[e]=n),n}}}),u.getters=u.get,u.events=new t,u.backup=c(e.state),u.status=new a(o.IDLE,()=>{u.events.publish(o.IDLE,u)}),Object.keys(e.subscribe||{}).forEach(t=>{u.events.subscribe(t,()=>{e.subscribe[t]({state:u.stage,commit:u.commit,dispatch:u.dispatch}),u.stage.commit()})}),Object.keys(e.events||{}).forEach(t=>{u.events.subscribe(t,(...s)=>{e.events[t]({state:u.stage,commit:u.commit,dispatch:u.dispatch},...s),u.stage.commit()})});let b=c(e.state);u.state=new Proxy(b,{get:(t,e)=>"reset"===e?e=>{if(u.status.push(o.RESET),!r(e)&&e in u.backup){const s=u.stage[e];u.stage[e]=c(u.backup[e]),t[e]=c(u.backup[e]),u.events.publish(e,u.stage[e],s,u)}else u.stage=Object.assign(u.stage,c(u.backup)),t=Object.assign(t,c(u.backup));u.cache={},u.events.publish(o.RESET,u),u.status.pop()}:t[e],set(t,e,s){if("strict"===u.options.type&&![o.MUTATE,o.RESET,o.COMMIT].includes(u.status.current))throw new Error(`State variable ${e} should not be directly set outside of mutation or action.`);const n=t[e];return u.status.push(o.UPDATE),t[e]=s,u.stage[e]=s,u.cache={},u.events.publish(e,t[e],n,u),u.events.publish(o.UPDATE,e,t[e],n,u),u.status.pop(),!0}}),u.stage=new Proxy(c(b),{get:(t,e)=>"rollback"===e?e=>{u.status.push(o.ROLLBACK),!r(e)&&e in u.backup?t[e]=c(u.state[e]):t=Object.assign(t,c(u.state)),u.events.publish(o.ROLLBACK,u),u.status.pop()}:"commit"===e?e=>{u.status.push(o.COMMIT),i(e)?t=Object.assign(t,e):e=t;const s=[];Object.keys(e).forEach(t=>{(function t(e,s){if(typeof e!=typeof s)return!1;if(n(e)){if(e.length!=s.length)return!1;for(let n=0;n<e.length;n+=1)if(!t(e[n],s[n]))return!1;return!0}if(i(e)){const n=Object.keys(e).sort();if(!t(n,Object.keys(s).sort()))return!1;for(let i=0;i<n.length;i+=1){const r=n[i];if(!t(e[r],s[r]))return!1}return!0}return e===s})(b[t],e[t])||(b[t]=c(e[t]),s.push(t))}),0!==s.length&&(u.cache={},s.map(t=>{u.events.publish(t,u)}),u.events.publish(o.COMMIT,u)),u.status.pop()}:t[e],set:(t,e,s)=>(t[e]=s,!0)})}reset(){this.state.reset()}subscribe(t,e){this.events.subscribe(t,e)}commit(t,...e){const s=this;if("function"!=typeof s.mutations[t])throw new Error(`Mutation \`${t}\` does not exist.`);let n;s.status.push(o.MUTATE);try{n=s.mutations[t](s.stage,...e),s.stage.commit(),s.events.publish(o.MUTATE,t,...e,s)}finally{s.status.pop()}return n}async dispatch(t,...s){const n=this;if("function"!=typeof n.actions[t])throw new Error(`Action \`${t}\` does not exist.`);let i;n.status.push(o.DISPATCH);try{i=n.actions[t]({state:n.stage,commit:n.commit,dispatch:n.dispatch,getters:n.getters,get:n.get,apply:n.apply},...s),e(i)||(n.stage.commit(),n.events.publish(o.DISPATCH,t,...s,n))}catch(t){throw e(i)||n.stage.rollback(),t}finally{e(i)||n.status.pop()}return e(i)&&(i=i.then(()=>{n.stage.commit(),n.events.publish(o.DISPATCH,t,...s,n)}).catch(t=>{throw n.stage.rollback(),t}).finally(()=>{n.status.pop()})),i}},Observable:class{constructor(t,e){if(n(t=t||{}))return new p(t,e);if(i(t))return new h(t,e);throw new Error("Cannot create Observable type for non Array or Object type.")}},VuePlugin:function(t){if(Number(t.version.split(".")[0])>=2)t.mixin(O);else{const e=t.prototype._init;t.prototype._init=(t={})=>{t.init=t.init?[O.beforeCreate].concat(t.init):O.beforeCreate,e.call(this,t)}}}};module.exports=d;

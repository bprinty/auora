"use strict";class t{constructor(){this.events={}}get empty(){return 0===Object.keys(this.events).length}subscribe(t,s){const e=this;return t in e.events||(e.events[t]=[]),e.events[t].push(s)}publish(t,...s){return t in this.events?this.events[t].map(t=>t(...s)):[]}}function s(t){return void 0!==t&&"function"==typeof t.then}function e(t){return"function"==typeof t}function n(t){return Array.isArray(t)}function i(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}function r(t){return void 0===t}function c(t){if(n(t))return t.map(t=>c(t));if(i(t)){const s={};return Object.keys(t).forEach(e=>{s[e]=c(t[e])}),s}return t}const a={IDLE:"idle",RESET:"reset",ROLLBACK:"rollback",COMMIT:"commit",MUTATE:"mutate",DISPATCH:"dispatch"};class u{constructor(t,s){this.idle=t,this.stack=[t],this.callback=s||function(){}}get current(){return this.stack[this.stack.length-1]}get previous(){return this.stack.length<2?this.idle:this.stack[this.stack.length-2]}reset(){this.stack=[this.idle],this.callback()}push(t){this.stack.push(t)}pop(){let t;return this.stack.length>1&&(t=this.stack.pop(),1===this.stack.length&&this.callback()),t}}const o=["push","pop","shift","unshift","splice"];class h{constructor(s){this.events=new t,e(s)&&(this.events.subscribe("update",s),this.events.subscribe("delete",s),this.events.subscribe("reset",s))}subscribe(t,s){e(t)?(this.events.subscribe("update",s),this.events.subscribe("delete",s),this.events.subscribe("reset",s)):e(s)&&this.events.subscribe(t,s)}publish(t,...s){this.events.publish(t,...s)}}class p extends h{constructor(t,s,c=!0){super(s);const a=this,u=Object.assign({},t);return c&&Object.keys(t).forEach(e=>{i(t[e])?t[e]=new p(t[e],s):n(t[e])&&(t[e]=new b(t[e],s))}),new Proxy(t,{get:(o,h)=>"reset"===h?()=>{Object.keys(o).forEach(t=>{t in u?o[t]=u[t]:delete o[t]}),a.publish("reset")}:"update"===h?e=>{c&&Object.keys(e).forEach(r=>{i(e[r])?e[r]=new p(e[r],s):n(t[r])&&(e[r]=new b(e[r],s))}),o=Object.assign(o,e),a.publish("update")}:"subscribe"===h?(t,s)=>{e(t)&&r(s)?a.subscribe("update",t):a.subscribe(t,s)}:o[h],set:(t,e,r)=>(i(r)&&c?t[e]=new p(r,s):n(r)&&c?t[e]=new b(r,s):t[e]=r,a.publish(e),a.publish("update",e,r),!0),deleteProperty:(t,s)=>(delete t[s],a.publish(s),a.publish("delete",s),!0)})}}class b extends h{constructor(t,s,c=!0){super(s);const a=this,u=t.map(t=>i(t)?Object.assign({},t):n(t)?t.slice():t);return c&&(t=t.map(t=>i(t)?new p(t,s):n(t)?new b(t,s):t)),new Proxy(t,{get(t,s){if("reset"===s)return()=>{t.splice(0,t.length),t.push(...u),a.publish("reset")};if("subscribe"===s)return(t,s)=>{e(t)&&r(s)?a.subscribe("update",t):a.subscribe(t,s)};const n=t[s];return"function"==typeof n?o.includes(s)?(...e)=>{const n=t[s](...e);return a.publish(s),a.publish("update"),n}:n.bind(t):n},set:(t,e,r)=>(i(r)&&c?t[e]=new p(r,s):n(r)&&c?t[e]=new b(r,s):t[e]=r,a.publish(e),a.publish("update",e,r),!0),deleteProperty:(t,s)=>(t.splice(s,1),a.publish(s),a.publish("delete",s),!0)})}}var l={Store:class{constructor(s={}){const n=this;s.state=s.state||{},n.options=s.options||{recurse:!1},n.stage={},n.state={},n.actions={},n.getters={},n.mutations={},n.register(s),Object.keys(s.state).forEach(t=>{n.mutations[t]=(s,e)=>{s[t]=e}}),Object.assign(n.mutations,s.mutations),n.apply=new Proxy(n.actions,{get(t,s){if(s in t)return(...t)=>n.dispatch(s,...t)}}),n.cache={},n.get=new Proxy(n.getters,{get(t,s){if(s in t){if(s in n.cache)return n.cache[s];{const i=t[s](n.state);return e(i)||(n.cache[s]=i),i}}}}),n.events=new t,n.backup=c(s.state),n.status=new u(a.IDLE,()=>{n.events.publish(a.IDLE,n.state)}),Object.keys(s.events||{}).forEach(t=>n.subscribe(t,s.events[t]))}register(t){Object.assign(this.state,c(t.state)||{}),Object.assign(this.stage,c(t.state)||{}),Object.assign(this.getters,t.getters||{}),Object.assign(this.actions,t.actions||{}),Object.assign(this.mutations,t.mutations||{}),this.nested=[],Object.keys(this.state).forEach(t=>{i(this.state[t])&&this.nested.push(t)})}reset(t){const s=this;s.status.push(a.RESET),void 0===t?(s.state=c(s.backup),s.stage=c(s.backup)):(s.state[t]=c(s.backup[t]),s.stage[t]=c(s.backup[t])),s.events.publish(a.RESET),s.status.pop()}flush(t=!0){const s=this;t&&s.status.push(a.COMMIT),s.options.recurse?s.state=c(s.stage):0===s.nested.length?s.state={...s.stage}:(Object.keys(s.stage).forEach(t=>{s.nested.includes(t)?s.state[t]={...s.stage[t]}:s.state[t]=s.stage[t]}),Object.keys(s.state).forEach(t=>{t in s.stage||delete s.state[t]})),s.cache={},t&&(s.events.publish(a.COMMIT),s.status.pop())}rollback(t=!0){const s=this;t&&s.status.push(a.ROLLBACK),s.stage=c(s.state),t&&(s.events.publish(a.ROLLBACK),s.status.pop())}subscribe(t,s){const e=this,n=Object.values(a);if(!n.includes(t)){const s=n.join(", ");throw new Error(`Cannot subscribe to \`${t}\`. Valid choices are: ${s}`)}e.events.subscribe(t,(...t)=>{s(e.stage,...t),e.flush(!1)})}commit(t,...s){const e=this;if("function"!=typeof e.mutations[t])throw new Error(`Mutation \`${t}\` does not exist.`);let n;e.status.push(a.MUTATE);try{n=e.mutations[t](e.stage,...s),e.flush(),e.events.publish(a.MUTATE,t,...s)}finally{e.status.pop()}return n}async dispatch(t,...e){const n=this;if("function"!=typeof n.actions[t])throw new Error(`Action \`${t}\` does not exist.`);let i;n.status.push(a.DISPATCH);try{i=n.actions[t]({state:n.stage,commit:n.commit,flush:()=>n.flush(!1),dispatch:n.dispatch,get:n.get,apply:n.apply},...e),s(i)||n.status.previous===a.IDLE&&(n.flush(),n.events.publish(a.DISPATCH,t,...e))}catch(t){throw s(i)||n.rollback(),t}finally{s(i)||n.status.pop()}return s(i)&&(i=i.then(()=>{n.status.previous===a.IDLE&&(n.flush(),n.events.publish(a.DISPATCH,t,...e))}).catch(t=>{throw n.rollback(),t}).finally(()=>{n.status.pop()})),i}},Observable:class{constructor(t,s){if(n(t=t||{}))return new b(t,s);if(i(t))return new p(t,s);throw new Error("Cannot create Observable type for non Array or Object type.")}}};module.exports=l;

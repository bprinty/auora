"use strict";class t{constructor(){this.events={}}get empty(){return 0===Object.keys(this.events).length}subscribe(t,s){const e=this;return t in e.events||(e.events[t]=[]),e.events[t].push(s)}publish(t,...s){return t in this.events?this.events[t].map(t=>t(...s)):[]}}function s(t){return void 0!==t&&"function"==typeof t.then}function e(t){return"function"==typeof t}function i(t){return Array.isArray(t)}function n(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}function r(t){return void 0===t}function c(t){if(i(t))return t.map(t=>c(t));if(n(t)){const s={};return Object.keys(t).forEach(e=>{s[e]=c(t[e])}),s}return t}const u={IDLE:"idle",RESET:"reset",ROLLBACK:"rollback",COMMIT:"commit",MUTATE:"mutate",DISPATCH:"dispatch"};class a{constructor(t,s){this.idle=t,this.stack=[t],this.callback=s||function(){}}get current(){return this.stack[this.stack.length-1]}get previous(){return this.stack.length<2?this.idle:this.stack[this.stack.length-2]}reset(){this.stack=[this.idle],this.callback()}push(t){this.stack.push(t)}pop(){let t;return this.stack.length>1&&(t=this.stack.pop(),1===this.stack.length&&this.callback()),t}}const o=["push","pop","shift","unshift","splice"];class h{constructor(s){this.events=new t,e(s)&&(this.events.subscribe("update",s),this.events.subscribe("delete",s),this.events.subscribe("reset",s))}subscribe(t,s){e(t)?(this.events.subscribe("update",s),this.events.subscribe("delete",s),this.events.subscribe("reset",s)):e(s)&&this.events.subscribe(t,s)}publish(t,...s){this.events.publish(t,...s)}}class p extends h{constructor(t,s,c=!0){super(s);const u=this,a=Object.assign({},t);return c&&Object.keys(t).forEach(e=>{n(t[e])?t[e]=new p(t[e],s):i(t[e])&&(t[e]=new l(t[e],s))}),new Proxy(t,{get:(o,h)=>"reset"===h?()=>{Object.keys(o).forEach(t=>{t in a?o[t]=a[t]:delete o[t]}),u.publish("reset")}:"update"===h?e=>{c&&Object.keys(e).forEach(r=>{n(e[r])?e[r]=new p(e[r],s):i(t[r])&&(e[r]=new l(e[r],s))}),o=Object.assign(o,e),u.publish("update")}:"subscribe"===h?(t,s)=>{e(t)&&r(s)?u.subscribe("update",t):u.subscribe(t,s)}:o[h],set:(t,e,r)=>(n(r)&&c?t[e]=new p(r,s):i(r)&&c?t[e]=new l(r,s):t[e]=r,u.publish(e),u.publish("update",e,r),!0),deleteProperty:(t,s)=>(delete t[s],u.publish(s),u.publish("delete",s),!0)})}}class l extends h{constructor(t,s,c=!0){super(s);const u=this,a=t.map(t=>n(t)?Object.assign({},t):i(t)?t.slice():t);return c&&(t=t.map(t=>n(t)?new p(t,s):i(t)?new l(t,s):t)),new Proxy(t,{get(t,s){if("reset"===s)return()=>{t.splice(0,t.length),t.push(...a),u.publish("reset")};if("subscribe"===s)return(t,s)=>{e(t)&&r(s)?u.subscribe("update",t):u.subscribe(t,s)};const i=t[s];return"function"==typeof i?o.includes(s)?(...e)=>{const i=t[s](...e);return u.publish(s),u.publish("update"),i}:i.bind(t):i},set:(t,e,r)=>(n(r)&&c?t[e]=new p(r,s):i(r)&&c?t[e]=new l(r,s):t[e]=r,u.publish(e),u.publish("update",e,r),!0),deleteProperty:(t,s)=>(t.splice(s,1),u.publish(s),u.publish("delete",s),!0)})}}var b={Store:class{constructor(s={}){const i=this;s.state=s.state||{},i.options=s.options||{type:"transactional",recurse:!1},i.mutations={},Object.keys(s.state).forEach(t=>{i.mutations[t]=(s,e)=>{s[t]=e}}),Object.assign(i.mutations,s.mutations),i.actions=s.actions||{},i.apply=new Proxy(i.actions,{get(t,s){if(s in t)return(...t)=>i.dispatch(s,...t)}}),i.cache={},i.getters=s.getters||{},i.get=new Proxy(i.getters,{get(t,s){if(s in t){if(s in i.cache)return i.cache[s];{const n=t[s](i.state);return e(n)||(i.cache[s]=n),n}}}}),i.events=new t,i.backup=c(s.state),i.status=new a(u.IDLE,()=>{i.events.publish(u.IDLE,i.state)}),Object.keys(s.events||{}).forEach(t=>i.subscribe(t,s.events[t])),i.state=c(s.state),i.stage=c(s.state)}register(t){Object.assign(this.state,c(t.state)||{}),Object.assign(this.stage,c(t.state)||{}),Object.assign(this.getters,t.getters||{}),Object.assign(this.actions,t.actions||{})}reset(){this.status.push(u.RESET),this.state=c(this.backup),this.stage=c(this.backup),this.events.publish(u.RESET),this.status.pop()}flush(t=!0){const s=this;t&&s.status.push(u.COMMIT),s.options.recurse?s.state=c(s.stage):s.state={...s.stage},s.cache={},t&&(s.events.publish(u.COMMIT),s.status.pop())}rollback(t=!0){const s=this;t&&s.status.push(u.ROLLBACK),s.options.recurse?s.stage=c(s.state):s.stage={...s.state},t&&(s.events.publish(u.ROLLBACK),s.status.pop())}subscribe(t,s){const e=this,i=Object.values(u);if(!i.includes(t)){const s=i.join(", ");throw new Error(`Cannot subscribe to \`${t}\`. Valid choices are: ${s}`)}e.events.subscribe(t,(...t)=>{s(e.stage,...t),e.flush(!1)})}commit(t,...s){const e=this;if("function"!=typeof e.mutations[t])throw new Error(`Mutation \`${t}\` does not exist.`);let i;e.status.push(u.MUTATE);try{i=e.mutations[t](e.stage,...s),e.flush(),e.events.publish(u.MUTATE,t,...s)}finally{e.status.pop()}return i}async dispatch(t,...e){const i=this;if("function"!=typeof i.actions[t])throw new Error(`Action \`${t}\` does not exist.`);let n;i.status.push(u.DISPATCH);try{n=i.actions[t]({state:i.stage,commit:i.commit,flush:()=>i.flush(!1),dispatch:i.dispatch,get:i.get,apply:i.apply},...e),s(n)||i.status.previous===u.IDLE&&(i.flush(),i.events.publish(u.DISPATCH,t,...e))}catch(t){throw s(n)||i.rollback(),t}finally{s(n)||i.status.pop()}return s(n)&&(n=n.then(()=>{i.status.previous===u.IDLE&&(i.flush(),i.events.publish(u.DISPATCH,t,...e))}).catch(t=>{throw i.rollback(),t}).finally(()=>{i.status.pop()})),n}},Observable:class{constructor(t,s){if(i(t=t||{}))return new l(t,s);if(n(t))return new p(t,s);throw new Error("Cannot create Observable type for non Array or Object type.")}}};module.exports=b;

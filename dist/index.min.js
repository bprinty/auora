"use strict";class t{constructor(){this.events={}}get empty(){return 0===Object.keys(this.events).length}subscribe(t,e){const s=this;return t in s.events||(s.events[t]=[]),s.events[t].push(e)}publish(t,...e){return t in this.events?this.events[t].map(t=>t(...e)):[]}}function e(t){return void 0!==t&&"function"==typeof t.then}function s(t){return"function"==typeof t}function n(t){return Array.isArray(t)}function i(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}function r(t){return void 0===t}function c(t){if(n(t))return t.map(t=>c(t));if(i(t)){const e={};return Object.keys(t).forEach(s=>{e[s]=c(t[s])}),e}return t}const a={IDLE:"idle",RESET:"reset",ROLLBACK:"rollback",UPDATE:"update",COMMIT:"commit",MUTATE:"mutate",DISPATCH:"dispatch"};class u{constructor(t,e){this.idle=t,this.stack=[t],this.callback=e||function(){}}get current(){return this.stack[this.stack.length-1]}get previous(){return this.stack.length<2?this.idle:this.stack[this.stack.length-2]}reset(){this.stack=[this.idle],this.callback()}push(t){this.stack.push(t)}pop(){let t;return this.stack.length>1&&(t=this.stack.pop(),1===this.stack.length&&this.callback()),t}}const o=["push","pop","shift","unshift","splice"];class h{constructor(e){this.events=new t,s(e)&&(this.events.subscribe("update",e),this.events.subscribe("delete",e),this.events.subscribe("reset",e))}subscribe(t,e){s(t)?(this.events.subscribe("update",e),this.events.subscribe("delete",e),this.events.subscribe("reset",e)):s(e)&&this.events.subscribe(t,e)}publish(t,...e){this.events.publish(t,...e)}}class p extends h{constructor(t,e,c=!0){super(e);const a=this,u=Object.assign({},t);return c&&Object.keys(t).forEach(s=>{i(t[s])?t[s]=new p(t[s],e):n(t[s])&&(t[s]=new b(t[s],e))}),new Proxy(t,{get:(o,h)=>"reset"===h?()=>{Object.keys(o).forEach(t=>{t in u?o[t]=u[t]:delete o[t]}),a.publish("reset")}:"update"===h?s=>{c&&Object.keys(s).forEach(r=>{i(s[r])?s[r]=new p(s[r],e):n(t[r])&&(s[r]=new b(s[r],e))}),o=Object.assign(o,s),a.publish("update")}:"subscribe"===h?(t,e)=>{s(t)&&r(e)?a.subscribe("update",t):a.subscribe(t,e)}:o[h],set:(t,s,r)=>(i(r)&&c?t[s]=new p(r,e):n(r)&&c?t[s]=new b(r,e):t[s]=r,a.publish(s),a.publish("update",s,r),!0),deleteProperty:(t,e)=>(delete t[e],a.publish(e),a.publish("delete",e),!0)})}}class b extends h{constructor(t,e,c=!0){super(e);const a=this,u=t.map(t=>i(t)?Object.assign({},t):n(t)?t.slice():t);return c&&(t=t.map(t=>i(t)?new p(t,e):n(t)?new b(t,e):t)),new Proxy(t,{get(t,e){if("reset"===e)return()=>{t.splice(0,t.length),t.push(...u),a.publish("reset")};if("subscribe"===e)return(t,e)=>{s(t)&&r(e)?a.subscribe("update",t):a.subscribe(t,e)};const n=t[e];return"function"==typeof n?o.includes(e)?(...s)=>{const n=t[e](...s);return a.publish(e),a.publish("update"),n}:n.bind(t):n},set:(t,s,r)=>(i(r)&&c?t[s]=new p(r,e):n(r)&&c?t[s]=new b(r,e):t[s]=r,a.publish(s),a.publish("update",s,r),!0),deleteProperty:(t,e)=>(t.splice(e,1),a.publish(e),a.publish("delete",e),!0)})}}var l={Store:class{constructor(e={}){const o=this;e.state=e.state||{},o.options=e.options||{type:"transactional"},o.mutations={},Object.keys(e.state).forEach(t=>{o.mutations[t]=(e,s)=>{e[t]=s}}),Object.assign(o.mutations,e.mutations),o.actions=e.actions||{},o.apply=new Proxy(o.actions,{get(t,e){if(e in t)return(...t)=>o.dispatch(e,...t)}}),o.cache={},o.getters=e.getters||{},o.get=new Proxy(o.getters,{get(t,e){if(e in t){if(e in o.cache)return o.cache[e];{const n=t[e](o.state);return s(n)||(o.cache[e]=n),n}}}}),o.events=new t,o.backup=c(e.state),o.status=new u(a.IDLE,()=>{o.events.publish(a.IDLE,o)}),Object.keys(e.subscribe||{}).forEach(t=>{o.events.subscribe(t,()=>{e.subscribe[t]({state:o.stage,commit:o.commit,dispatch:o.dispatch}),o.stage.commit()})}),Object.keys(e.events||{}).forEach(t=>{o.events.subscribe(t,(...s)=>{e.events[t]({state:o.stage,commit:o.commit,dispatch:o.dispatch},...s),o.stage.commit()})});const h=c(e.state);o.state=new Proxy(h,{get:(t,e)=>"reset"===e?e=>{if(o.status.push(a.RESET),!r(e)&&e in o.backup){const s=o.stage[e];o.stage[e]=c(o.backup[e]),t[e]=c(o.backup[e]),o.events.publish(e,o.stage[e],s,o)}else o.stage=Object.assign(o.stage,c(o.backup)),t=Object.assign(t,c(o.backup));o.cache={},o.events.publish(a.RESET,o),o.status.pop()}:t[e],set(t,e,s){if("strict"===o.options.type&&![a.MUTATE,a.RESET,a.COMMIT].includes(o.status.current))throw new Error(`State variable ${e} should not be directly set outside of mutation or action.`);const n=t[e];return o.status.push(a.UPDATE),t[e]=s,o.stage[e]=s,o.cache={},o.events.publish(e,t[e],n,o),o.events.publish(a.UPDATE,e,t[e],n,o),o.status.pop(),!0}}),o.stage=new Proxy(c(h),{get:(t,e)=>"rollback"===e?e=>{o.status.push(a.ROLLBACK),!r(e)&&e in o.backup?t[e]=c(o.state[e]):t=Object.assign(t,c(o.state)),o.events.publish(a.ROLLBACK,o),o.status.pop()}:"commit"===e?e=>{o.status.push(a.COMMIT),i(e)?t=Object.assign(t,e):e=t;const s=[];Object.keys(e).forEach(t=>{(function t(e,s){if(typeof e!=typeof s)return!1;if(n(e)){if(e.length!==s.length)return!1;for(let n=0;n<e.length;n+=1)if(!t(e[n],s[n]))return!1;return!0}if(i(e)){const n=Object.keys(e).sort();if(!t(n,Object.keys(s).sort()))return!1;for(let i=0;i<n.length;i+=1){const r=n[i];if(!t(e[r],s[r]))return!1}return!0}return e===s})(h[t],e[t])||(h[t]=c(e[t]),s.push(t))}),Object.keys(h).forEach(e=>{e in t||delete h[e]}),0!==s.length&&(o.cache={},s.forEach(t=>o.events.publish(t,o)),o.events.publish(a.COMMIT,o)),o.status.pop()}:t[e],set:(t,e,s)=>(t[e]=s,!0)})}register(t){Object.assign(this.state,t.state||{}),Object.assign(this.getters,t.getters||{}),Object.assign(this.actions,t.actions||{})}reset(){this.state.reset()}subscribe(t,e){this.events.subscribe(t,e)}commit(t,...e){const s=this;if("function"!=typeof s.mutations[t])throw new Error(`Mutation \`${t}\` does not exist.`);let n;s.status.push(a.MUTATE);try{n=s.mutations[t](s.stage,...e),s.stage.commit(),s.events.publish(a.MUTATE,t,...e,s)}finally{s.status.pop()}return n}async dispatch(t,...s){const n=this;if("function"!=typeof n.actions[t])throw new Error(`Action \`${t}\` does not exist.`);let i;n.status.push(a.DISPATCH);try{i=n.actions[t]({state:n.stage,commit:n.commit,dispatch:n.dispatch,get:n.get,apply:n.apply},...s),e(i)||n.status.previous===a.IDLE&&(n.stage.commit(),n.events.publish(a.DISPATCH,t,...s,n))}catch(t){throw e(i)||n.stage.rollback(),t}finally{e(i)||n.status.pop()}return e(i)&&(i=i.then(()=>{n.status.previous===a.IDLE&&(n.stage.commit(),n.events.publish(a.DISPATCH,t,...s,n))}).catch(t=>{throw n.stage.rollback(),t}).finally(()=>{n.status.pop()})),i}},Observable:class{constructor(t,e){if(n(t=t||{}))return new b(t,e);if(i(t))return new p(t,e);throw new Error("Cannot create Observable type for non Array or Object type.")}}};module.exports=l;
